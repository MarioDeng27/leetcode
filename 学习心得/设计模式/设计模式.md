# 设计模式

## 第1集 设计模式简介

![image-20211214172752424](pics/image-20211214172752424.png)---

![image-20211214172917258](pics/image-20211214172917258.png)---

## 第2集 面向对象设计原则

 ![image-20211214173318057](pics/image-20211214173318057.png)---

![image-20211214173719241](pics/image-20211214173719241.png)---

![image-20211214174153501](pics/image-20211214174153501.png)---

![image-20211214174908146](pics/image-20211214174908146.png)---

![image-20211214175329366](pics/image-20211214175329366.png)---

![image-20211214175430845](pics/image-20211214175430845.png)---

![image-20211214175701734](pics/image-20211214175701734.png)---

![image-20211214175909034](pics/image-20211214175909034.png)---

![image-20211214180115897](pics/image-20211214180115897.png)--- 

![image-20211214180210650](pics/image-20211214180210650.png)---

![image-20211214180328376](pics/image-20211214180328376.png)---  

![image-20211214181103676](pics/image-20211214181103676.png)---

## 第3集 模板方法

### 1. Template Method 设计模式 

![image-20211214212727058](pics/image-20211214212727058.png)---

![image-20211214212750694](pics/image-20211214212750694.png)---

![image-20211214211052073](pics/image-20211214211052073.png)---

![image-20211214211153897](pics/image-20211214211153897.png)--- 

![image-20211214212028699](pics/image-20211214212028699.png)

**以后每学一个设计模式就要这样通过红色框来表示稳定部分，蓝色框表示变化部分**

![image-20211214212447053](pics/image-20211214212447053.png)---

## 第4集 策略模式

### 2. Strategy 策略模式

用扩展的方式来应对未来算法需求的变化（增加子类）

 [19:00] 复用性：编译，部署之后二进制意义的复用,而不是某些不变的代码片段

![image-20211214214207755](pics/image-20211214214207755.png)---

![image-20211214214414750](pics/image-20211214214414750.png)---

## 第5集 观察者模式

### 3. Observer 观察者模式 

也叫Event

![image-20211215215140561](pics/image-20211215215140561.png)---

![image-20211215221848157](pics/image-20211215221848157.png)---

![image-20211215222338823](pics/image-20211215222338823.png)---

![image-20211215222617131](pics/image-20211215222617131.png)---

![image-20211215223013627](pics/image-20211215223013627.png)

## 第6集 装饰模式

### 4. Decorator 装饰模式

具有扩展作用

特点：Decorator类，继承某一基类，然后类中又组合包含了基类成员

---

![image-20211216165430541](pics/image-20211216165430541.png)

---

编译时装配和运行时装配

---

加入装饰器前的类结构![image-20211216172048918](pics/image-20211216172048918.png)

---

加入装饰器后的结构![image-20211216171908015](pics/image-20211216171908015.png)

---

![image-20211216172914711](pics/image-20211216172914711.png)

---

![image-20211216172948543](pics/image-20211216172948543.png)

---

![image-20211216173231906](pics/image-20211216173231906.png)

---

![image-20211216173250417](pics/image-20211216173250417.png)

---



## 第7集 桥模式

### 5. Bridge 桥模式

和装饰模式非常相似，但是桥模式并没有一个公共的祖先类，而是在抽象类中组合包含一个指向实现基类的指针

![image-20211216191509759](pics/image-20211216191509759.png)

---

![](pics/image-20211216203800645.png)

---

![image-20211216191835480](pics/image-20211216191835480.png)

---



## 第8集 工厂方法

### 6. Factory Method 工厂方法

---

![image-20211217205616430](pics/image-20211217205616430.png)

---

![image-20211217212051787](pics/image-20211217212051787.png)

---

![image-20211217212522293](pics/image-20211217212522293.png)

---

![image-20211217212542705](pics/image-20211217212542705.png)

---



## 第9集 抽象工厂

### 7. Abstract Factory 抽象工厂

其实就是叫做Family Factory，让相互关联的工厂生产方法放在同一个工厂中

---

![image-20211217213550447](pics/image-20211217213550447.png)

---

![image-20211217214900655](pics/image-20211217214900655.png)

---

![image-20211217215544742](pics/image-20211217215544742.png)

---

红色是稳定部分，不需要在改动

蓝色是一种变化方向，绿色是另一种变化方向

---

![image-20211217215652931](pics/image-20211217215652931.png)

---

##   第10集 原型模式

### 8. Prototype 原型模式

通过克隆自己来创建对象

---

![image-20211219222324676](pics/image-20211219222324676.png)

---

![image-20211219222401684](pics/image-20211219222401684.png)

----

它和工厂方法的区别在于：如果当前对象状态很复杂，比如带有各种属性，若用工厂创建对象的话，这个创建方法会很麻烦，而如果当前直接有一个可用的对象，则以它作为原型，将其状态复制到新的对象再去操作，会更方便。

创建对象简单的情况可以用工厂，复杂用原型，两种都是来解决new的问题

---

![image-20211219224219428](pics/image-20211219224219428.png)

---

![image-20211219223233604](pics/image-20211219223233604.png)

---





## 第11集 构建器

### 9. Builder 构建器

没太看懂。。。

---

![image-20211219224702486](pics/image-20211219224702486.png)

---

C++中，构造函数中使用当前类的虚函数只能实现静态绑定，不能实现动态绑定，若该虚函数是纯虚函数即并没有真正实现则会报错。

---

![image-20211219230511125](pics/image-20211219230511125.png)

---

![image-20211219230607108](pics/image-20211219230607108.png)

---

![image-20211219230702614](pics/image-20211219230702614.png)

---

