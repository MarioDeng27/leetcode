https://blog.csdn.net/weixin_40736096/article/details/79711180?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
两个函数的头文件是<functional>

建堆的时候，默认是大根堆，第三个参数用greater<T>会变成小根堆；

排序的时候，默认是从小到大，但是第三个参数用greater<T>会变成从大到小

另外说一句，make_heap等heap操作函数在头文件<algorithm>里。

注意：　less 是前者小于后者，即实现从小到大排序，但是在创建优先队列时会变成大顶堆
template<class _Ty = void>
    struct less
    {    // functor for operator<
    typedef _Ty first_argument_type;
    typedef _Ty second_argument_type;
    typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {    // apply operator< to operands
        return (_Left < _Right);
        }
    };
注意：　greater 是前者大于后者，即实现从大到小排序，但是在创建优先队列时会变成小顶堆
template<class _Ty = void>
    struct greater
    {    // functor for operator>
    typedef _Ty first_argument_type;
    typedef _Ty second_argument_type;
    typedef bool result_type;

    constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {    // apply operator> to operands
        return (_Left > _Right);
        }
    };

总之：大顶堆和小顶堆的实现的比较方式和排序的比较方式相反，不管是但关键词排序还是多关键词排序


