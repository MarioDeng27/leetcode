# MySQL索引连环18问！

https://www.nowcoder.com/discuss/639644?source_id=profile_create_nctrack&channel=-1

https://blog.csdn.net/GaleZhang/article/details/109158196

1. 索引是什么？

   - 数据库中的索引是一种数据结构，它已经排完序，它相当于书的目录，可以提高查询效率
   - 索引是一个文件，它占用存储空间

   

2. 索引有哪些优缺点？

   - 优点：

     - 可以提高查询效率
     - 通过使用索引，在查询过程中，使用优化隐藏器，提高系统的性能

   - 缺点：

     - 时间方面：创建索引和维护索引要耗费时间，当对表中的数据进行增加或者删除或者修改，索引也要动态的维护，从而降低增删改的效率
     - 空间方面：索引是个文件，本身占用物理空间

     

3. MySQL有哪几种索引类型？

   - 存储的数据结构分：

     - BTree索引,Hash索引, FULLTEXT, RTREE

   - 应用层次分：

     - 普通索引：即一个索引只包含单个列，一个表-可以有多个单列索引
     - 唯一索引：索引列的值必须唯一，但允许有空值
     - 复合索引：多个列值组成一个索引，专门用于组合搜索，其效率大于索引合并
     - 聚簇索引/聚集索引：InnoDB的聚簇索引其实就是同一个结构中保存了BTree索引和数据行
     - 非聚簇索引/非聚集索引：不是聚簇索引，就是非聚簇索引

     

4. 说一下索引的底层实现

   - B-Tree索引（MySQL使用B+Tree）: 

     - B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。

   - B+Tree索引：https://www.cnblogs.com/xueqiuqiu/articles/8779029.html

     - MySQL中索引所采用的存储结构，数据全在叶子节点上，并且增加了访问指针，每个叶子节点都指向相邻叶子节点的地址，形成一个链表。它进行范围查找只要找到两个节点，遍历链表即可。而B-Tree需要进行一次中序遍历按序来扫，相比之下B+Tree效率更高
     - 性质：
       - 一个非叶子节点，它有n棵子树，其中包含了n个关键字key（B-Tree是n-1个关键字），这些关键字不保存数据，只用来索引
       - 所有的非叶子结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字
       - 所有叶子节点都包含了全部的关键字信息，以及对应的数据内容（聚集索引：整行真实数据，非聚集索引：主键值或者指向主键索引B+树中主键对应节点的指针），且本身叶子节点根据关键字的大小从小到大顺序链接
       - 通常B+树上有两个头指针，一个指向根节点，一个指向关键字最小的叶子节点
       - B+ 树中，数据对象的插入和删除仅在叶节点上进行

   - Hash索引：

     - 基于哈希表实现，对于每一行数据，存储引擎都会对所有索引列的字段值计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。

     

5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？

   - B-Tree：两个方面
     - B+树的磁盘读写带价更低：B+树非叶子节点并没有保存对应的数据，所以相同大小的磁盘页可以容纳更多的关键字，它树的高度相比于B-Tree更低，相对而言IO读写次数就更少
     - 由于B+树的数据全部存储在叶子节点中，并且已排序，非叶子节点全部是关键字用作索引，B+树更适合方便范围查找，B树得通过重复中序遍历才能找到对应的点
   - Hash：
     - 适合等值查询，如=、in()，不支持范围查询
     - 虽然可以快速定位，但是没有排序
     - 因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 
     - 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 
     - 基于Hash表实现，只有Memory存储引擎显式支持哈希索引
   - 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高
   - 红黑树：树的高度随着数据量增加而增加，IO代价高

   

6. 讲一讲聚簇索引与非聚簇索引？https://blog.csdn.net/w605283073/article/details/95255618

   - 在InnoDB里，B+树的叶子节点存储了主键（关键字，索引）对应的整行数据就叫主键索引，也叫聚集索引，即将索引和数据放到了一块，找到索引就是找到了数据。聚簇索引只可能是主键，或者所有组成唯一键的所有列都为NOT NULL的第一个唯一索引，或者隐式创建的聚簇索引这三种情况

   - 而B+树的叶子节点存储了索引对应的主键的值（或者是指针）就是非主键索引，也被称为非聚集索引

   - 他们的区别：

     - 非聚集索引存储的是主键值，聚集索引存储的是表中实际的整行数据
     - InnoDB来说，通过K索引树找到对应的主键值，再到主键索引树找到对应的数据的过程叫做“回表”。
     - 通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可
     - 注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引

     

7. 非聚簇索引一定会回表查询吗？

   不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

   举个简单的例子，假设我们在学生表的成绩上建立了索引，那么当进行select score from student where score > 90的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。

   

8. 联合索引是什么？为什么需要注意联合索引中的顺序？https://blog.csdn.net/meng_xiaohua/article/details/106323779、http://www.pomit.cn/tr/2621513419164161

   MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

   

9. 讲一讲MySQL联合索引的最左匹配原则https://www.cnblogs.com/barrywxx/p/8592975.html

   最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
   mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

   =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

   

10. 讲一讲前缀索引？https://www.cnblogs.com/dataoblogs/p/14121929.html、https://jishuin.proginn.com/p/763bfbd4d494

    - 什么是？

      - 前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。

    - 为什么？

      - 前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。

    - 前缀索引对覆盖索引的影响？

      - #### https://www.cnblogs.com/dataoblogs/p/14121929.html

      - 其实就是前缀索引对应的B+树，它的key只是真实字段的一部分，它可能对应了有很多个字段（他们前面部分相同），所以这个时候它必须回表，对符合条件的那些记录进行一一筛选才行，降低了查询性能。

      

11. 了解索引下推吗？

    MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。 

    - 有了索引下推优化，可以在**减少回表次数** 
    - 在InnoDB中只针对二级索引有效

    

12. 怎么查看MySQL语句有没有用到索引?

    通过explain，如以下例子：

    ```mysql
    EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';
    ```

    type：`type` 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 `type` 字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。

    

13. 为什么官方建议使用自增长主键作为索引？https://www.cnblogs.com/lanqi/p/10185172.html

    - 从业务上来说：

      在设计库表时不需要考虑哪个字段作为主键，因为这些字段只是理论上唯一，比如说一本图书的编号，但实践过程中还是可能会出现重复的，所以最好还是选用与业务无关的自增ID作为主键，然后增加一个图书编号的唯一性约束。

    - 从技术上来说：

      如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会重新开辟新的页。总的来说就是可以提高查询和插入的性能。

      *结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。*

      自己的话：1. 索引的数据结构来分析，B+树的索引是有序的，那么自增ID作为主键后每次插入新数据就会被放到当前索引节点的后续位置，如果当前数据页满了，它会重新开辟一页。2. 在它插入新数据的过程中它会减少页分裂并且减少数据的移动。换句话来说就是可以提高插入的性能。而不用顺序索引则很有可能出现页分裂从而出现大量数据要移动。

      

14. 如何创建索引？

    1. 创建索引有三种方式。

       1、 在执行CREATE TABLE时创建索引

       ```mysql
       CREATE TABLE user_index2 (
           id INT auto_increment PRIMARY KEY,
           first_name VARCHAR (16),
           last_name VARCHAR (16),
           id_card VARCHAR (18),
           information text,
           KEY name (first_name, last_name),
           FULLTEXT KEY (information),
           UNIQUE KEY (id_card)
       );
       ```

       2、 使用ALTER TABLE命令去增加索引。

       ```mysql
       ALTER TABLE table_name ADD INDEX index_name (column_list);
       ```

       ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。

       其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。

       索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。
       3、 使用CREATE INDEX命令创建。

       ```
       CREATE INDEX index_name ON table_name (column_list)
       ```

15. 创建索引时需要注意什么？

    - 非空字段：应该要指定列为 NOT NULL， 因为有空值很难查询优化，因为使得比较运算变得更复杂。应该用0 或者 空串 或者 特殊的某个值来代替空值。
    - 在创建联合索引/复合索引的时候，取值离散大的字段，就是字段值的可能性多（唯一性越高）的字段放到联合索引的前面，可以通过count来计算，值越高说明离散程度越高。
    - 索引字段的值越小越好：数据库的数据存储以页为单位，单个字段的值占空间越小，所能容纳的字段值越多，一次IO操作读的字段值越多，效率越高。

16. 建索引的原则有哪些？

    - 在创建了联合索引后，查询过程中最好满足最左匹配原则，因为mysql在检索数据时从联合索引的最左边开始匹配，一直向右匹配直到遇到范围查询就停止匹配。
    - 其中等值查询的字段名相对顺序不影响是否使用索引。比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
    - 尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*) 。 在这个基础上如果要建立联合索引则区分度高的列要放在左边，这样会提升查询效率
    - 索引列不能参与计算，如果参与了计算就不会用到索引查询，可以将现有数据通过函数转换成索引列可以比较的值类型
    - 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

17. 使用索引查询一定能提高查询的性能吗？https://www.cnblogs.com/jasonboren/p/12878657.html

    通常通过索引查询数据比全表扫描要快。但是它有代价：索引是需要空间来存储的，也需要定期维护，每当有插入记录或者删除记录时，必须要维护索引本身，索引建的越多，维护成本越大。使用索引查询不一定能提高查询性能，两种情况:

    - 基于一个范围的检索，一般查询返回结果集大于表中记录数的30%。
    - 唯一性很差，大部分的值都重复，100W条数据，值的组成只有4种，这样使用索引查询会比全表慢。

    

18. 什么情况下不走索引（索引失效）？

    **总结两点：等值查询 = 或者 in（对同一字段的等值查询再or），不要对索引列进行运算（包括加减乘除和函数）**

    1. 使用!= 或者 <> 导致索引失效

    2. 类型不一致导致的索引失效

    3. 函数导致的索引失效

       ```mysql
       SELECT * FROM `user` WHERE DATE(create_time) = ``'2020-09-03'``;
       ```

    4. 运算符导致的索引失效

       如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。
       
       ```mysql
       SELECT * FROM `user` WHERE age - ``1` `= ``20``;
       ```

    5. OR引起的索引失效

       OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。
    
       ```mysql
       SELECT * FROM `user` WHERE `name` = ``'张三'` `OR height = ``'175'``;
       ```

    6. 模糊搜索导致的索引失效

       ```mysql
       SELECT * FROM `user` WHERE `name` LIKE ``'%'``;
       ```

       当`%`放在匹配字段前是不走索引的，放在后面才会走索引。

    7. NOT IN、NOT EXISTS导致索引失效



