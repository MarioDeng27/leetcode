# 网络编程



## 网络协议简介

TCP、RUDP

1. socket基础func简介：

   - 备注
     - 所有func都以阻塞模式分析
     - socket本质是一个维护tcp协议的内核对象
   - 等待连接   **int** **accept**(**int** sockfd, **struct** sockaddr *addr, socklen_t *addrlen);
     - 阻塞
     - 返回一个socket连接对象的fd
   - 发送 **ssize_t** send(**int** sockfd, **const** **void** *buf, **size_t** len, **int** flags)
     - 阻塞
     - 是否是直接网络发送？
     - 返回值具体含义
     - 上层该怎么处理返回值？
   - 接收数据 **ssize_t** recv(**int** sockfd, **void** *buf, **size_t** len, **int** flags）
     - 阻塞
     - 内核缓冲区
     - recv返回0表明什么？
     - 能否保证一次性就全部读到自己所需要的数据？
   - 关闭close **int** **close**(**int** fd);
     - 操作的socket描述符
     - 减少的是内核应用技术
     - 引用计数为0时，会关闭读写流
     - 如果close后，对端又发来数据，会产生什么后果？
   - 关闭shutdown **int** **shutdown**(**int** **socket**, **int** how);
     - 操作的是“流”，而不是socket描述符
     - how: SHUT_RD/SHUT_WR/SHUT_RDWR,,分别对应：0/1/2
     - 最后还是要释放内核对象close

2. Socket简化状态图

   ![img](http://www.plantuml.com/plantuml/png/JL1BoeCm4DxFAMRbuWTN_yv54Vg0Gl42fPGqCwM2JYGPAxrzOvIQJSZtXgc36gzZty7rxuRb3Xid3FE3PKINDYXBXOzM28i2kuHXePCZMIkqdGkSytidmbQPecYivK5Xgyr5k_m1Dd9sp7tqArvXllZqp5aeIST-qC_zODH4msHQnNzFW_6AWOKWayjy8xn69JS96Y7qRDzuEZUeRXs7EeRZYRu0)

3. 总结

   - 理解简单TCP基础，发送/接收缓冲区概念
   - close/shutdown区别
   - TCP和Socket结合，每个func对应TCP协议做了哪些事情以及相应的socket状态变化





## 网络编程模型

1. 问题

   - 既然都是阻塞func，那么服务器如何支持多个连接下的数据读写？
   - C10K问题

2. 分配进程/线程处理每个连接（让一个进程或者线程单独来处理连接申请）

   ```c
   ...
   listenfd = socket(AF_INET, SOCK_STREAM, 0);
   ...
   bind(listenfd, (SA *) &servaddr, sizeof(servaddr));
   listen(listenfd, LISTENQ);
   
   for ( ; ; ) {
   	clilen = sizeof(cliaddr);
   	connfd = accept(listenfd, (SA *) &cliaddr, &clilen);
   	if ( (childpid = fork()) == 0) {	/* child process */
   		handle_xxx(connfd);	/* process the request */
   		exit(0);
   	}
   	close(connfd);			/* parent closes connected socket */
   }
   ```

3. IO多路复用：select/poll/epoll/kqueue

   - 多路复用的本质是要解决什么问题？

   - epoll提供三个相关操作func：epoll_create/epoll_ctl/epoll_wait

     ```C
     int epoll_create1(int flags);
     int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
     int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
     ```

   - epoll

     - 在Kernel层创建一个“Scoket监视器”对象，替应用层“关注”需要关注的scoket set

     - 提供可以操作epoll 内核对象的接口：epoll_ctl

     - events：保存了当前已经收到事件的文件描述符

     - [epoll介绍]: https://zhuanlan.zhihu.com/p/63179839	"epoll"

       ```C
       struct epoll_event ev, *events;
       for(;;) {
           nfds = epoll_wait(kdpfd, events, maxevents, -1);
           for(n = 0; n < nfds; ++n) {
               if(events[n].data.fd == listener) {
                   client = accept(listener, (struct sockaddr *) &local,
                                   &addrlen);
                   ev.events = EPOLLIN | EPOLLOUT;
                   ev.data.fd = client;
                   if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &ev) < 0) {
                       fprintf(stderr, "epoll set insertion error: fd=%d0,client);
                       return -1;
                   }
               }
               else
                   do_use_fd(events[n].data.fd);
           }
       }
       ```

4. 总结：

   - 网络模型很多种，多路复用epoll模式比较常用
   - 理解如何管理socket对象





## 网络模块Prepare

1. 为什么网络要多线程

   - 如果在游戏主线程中处理网络IO会带来哪些问题？
   - 处理socket数据流那种方式合适？

2. 多线程模式会带来哪些问题

   - 数据在多个线程共享，带来竟态问题
   - 为了安全修改数据，加各种锁代码的开销
   - 如何跨线程管理对象生命周期管理

3. 如何设计一个多线程？

   - 避免大量竞态情况发生，把线程共享内存限制到最小
   - 合理地划分数据对象生命周期管理
   - 抽象出线程之间合适的通信方案

4. 线程间通信方案：命令队列

   - 每个线程提供一个接收命令的接口，线程自己处理接收到的命令
   - A线程需要B线程做“某件事”时，就把该“事件”抽象程一个Cmd（命令对象），发送给B线程即可
   - 线程之间通信严格按照命令队列方式进行

   ![img](A:\scripts\服务端知识点\Mario总结\网络编程\product_consume.png)

5. 总结

   - 网络线程单独抽象出来减少主线程压力
   - 多线程编程首要目标：降低复杂度
   - 拓展：多线程编程模式比较著名的几种
     - Actor （类似命令队列，Erlang）
     - CSP（基于channel，golang）
   - 拓展：还有几个比较常见概念
     - 原子操作CAS
     - 自旋锁
     - 无锁队列
     - 各种内核锁（mutex/pthread_cond_t...）



## 开源框架Libevent