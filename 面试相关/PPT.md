# P

#### 寻路优化：

1. 项目组关于寻路方面的基本信息

   1. 项目组中的场景是3D的，一个坐标可由（X,Y,Z）来表示，X和Y轴方向是连续的二维数组（2048*2048个格子），Z轴方向是通过链表来实现的，在同一个X,Y的位置上可能有多层，每一层都对应了相应的高度。
   2. 游戏中场景多，地形复杂，传送NPC多
   3. 项目组采用的算法主要是A*和迪杰斯特拉
   4. A* 算法主要是在引擎这一层通过C++代码来实现的，它主要用来判断起始坐标点到目的坐标点是否存在可达的实际路径，如果存在就返回一组坐标点，通过这些坐标点相连起来形成的路径是A*所计算出的代价值最小，速度最快的可达路径。
   5. 迪杰斯特拉算法是在客户端这边通过Lua代码来实现的，它主要用来判断起始坐标点到目的坐标点是否需要经过传送，也就是说一条路径并不是说玩家只能通过行走的方式到达目的地，还可以结合传送更加快速到达目标。而且当出现跨场景寻路时必定需要经过传送来到达目标场景的某个位置。所以迪杰斯特拉返回的是一组坐标点，其中包含了起点，终点以及所途径的传送点
   6. 传送点的类型：单目的传送点，多目的传送点。构建整个地图的一张图片
   7. 代价值的计算：

2. 寻路时间优化（主要就是减少A*的计算）

   1. 问题1：计算路径所花的时间，同场景400ms，跨场景800ms

      经过分析后得出，由传送点构成图的数据结构设计的不够完善，在优化前，传送点Node有字段From，To，分别表示起始传送点坐标和目标传送点坐标。而多目的传送点，会有多个Node，它们的From字段相同，但是To不一样，加入A可以到B，C，D他是这样来表示的A-B，A-C, A-D 通过3个Node来表示，相当于多目的传送点被描述为多组单目的传送点。在迪杰斯特拉算法中，起始点到A点的代价值每次更新都会被计算三次，结果都是相同的。

      优化后，给Node添加ToUnicoms字段，若To字段为nil，ToUnicoms不为nil则表示它是个多目的传送点，这样关于起点到A点的代价每次只需更新一次就可以。

   2. 问题2：假设现在玩家要从起点S到终点E，根据迪杰斯特拉算法得出结果是S->A->B->C->D->E, 

      1. S->A：起点S到第一个传送的出发点是通过走的方式
      2. A->B：A和B是一对传送点，玩家从A传送到B。
      3. B->C：B到C是通过走的方式，虽然B和C都是传送点，但是不是互通的
      4. C->D：C和D是一对传送点，玩家从C传送到D。
      5. D->E：D到终点E是通过走的方式。

      分析判断，前面五个步骤中哪些必须要走A*获得可达路径，其实除了传送之外，代价值是通过传送的代价公式来计算，其他都是通过A** 来计算代价值，也就是1，3，5这样的必须是通过A**来计算代价值的。但能不能提前把代价值计算好，让到一个表中，这样当被用到的时候，直接从表中获取数据就可以了。1和5这种情况肯定是不行的，因为起点相对而言是随机的，不可能把整张地图的点与传送点的距离都计算好。而3确实可以，因为B和C是两个不互通传送点，它们的位置是固定的（只要地图中传送坐标不修改），只要提前计算好B和C的A%代价值放到表里就可以。节省了运行时一部分计算A%的代价值。那1和5这种情况难道每次寻路都得重新计算嘛？并不是，因为在第一次使用A%计算完代价值之后，它们也会被存在一个表里，也许某一次寻路刚好起点和之前一次寻路的起点相同，刚好经过要走到某个传送点，那不就可以少一次计算了嘛。而且只要完的足够久，将来这样的记录多了之后，寻路就会越来越快。

3. 寻路空间优化

   1. A*算法主循环是从一个优先队列（小顶堆）上取出节点，不断对节点扩展跟踪，插入新的节点，直到找到解或者把节点遍历完毕。那么项目组中并没有使用STL库中的优先队列容器，而是使用一个固定长度的数组来模拟的，每一次加入新节点或者取出新节点后维护这个优先队列。

      思考1：为什么要定长数组，因为维护一个容量可变的数组会增加开销，因为每一次容量变动，都得先创建新的内存空间，将旧内存空间的数据完全拷贝到新空间后，就内存才会被释放，这样一增一删降低了系统性能。

      思考2：定长数组到底要多长？假设游戏是2D的，只有X,Y坐标，根据地图的大小可以知晓所包含的格子数是2048*2048 = 4194304个格子。那么考虑Z坐标后，会比这个值更大。那么由于我们采用A%算法，它是带有启发值的，相当于每一次选择下一个点的时候，它是带有倾向性的，会选择离终点更近的点。所以它并不会遍历整个地图的格子。项目组中这个数组的长度设为4\*65536 = 262144

      思考3：C++中寻路模块（A\*的使用）到底占用了多大的内存？

      寻路模块被抽象成一个叫CPathFinder的一个类，它使用了单例模式，那么该单例到底用了多大的空间呢？经过VS调试可以知道，共占用了12.2 MB左右的空间。然后客户端的大佬就提要求说，12MB太大了，能不能减小。

      经过分析后，其实就是刚刚我说的定长数组以及为了维护这个数组的一些辅助数据占了大头，数组的元素类型是CNode类型，通过C库中的sizeof()计算了CNode这个类实例化一个对象后，该对象占用的内存大小为40字节以及一个辅助指针8字节，最后可得占用内存为：65536\*4\*(40+8)/1024/1024 = 12MB。<font color='red'>所以只要减少了这个数组的长度就可以减小内存的占用。</font>

   2. 其实这个长度主要根据A\*算法到底遍历了多少个点，所以我编写了一些代码进行测试，发现差不多可以占90%大部分的寻路执行A\*基本上遍历的点会在1W个以下，一些复杂的路线肯能会到达3W，因为地形的缘故或者那部分没有添加Mesh点。而几乎没有超过10W以上，A\*遍历10W个点以上也就基本意味着，并没有找到一条合适的路径。所以我认为最终可以将长度减少值65536或者3W，但为了游戏的稳定测试，暂时减少了一半65536\*2，如果测试下来没问题在减少至65536，再接下去看看是否还能优化。

4. 寻路Bug

